{
  "_args": [
    [
      {
        "raw": "sparql-client-2",
        "scope": null,
        "escapedName": "sparql-client-2",
        "name": "sparql-client-2",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/home/andrew/expressproj"
    ]
  ],
  "_from": "sparql-client-2@latest",
  "_id": "sparql-client-2@0.6.1",
  "_inCache": true,
  "_location": "/sparql-client-2",
  "_nodeVersion": "6.9.0",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/sparql-client-2-0.6.1.tgz_1480193884562_0.6647129561752081"
  },
  "_npmUser": {
    "name": "eddieantonio",
    "email": "easantos@ualberta.ca"
  },
  "_npmVersion": "3.10.8",
  "_phantomChildren": {},
  "_requested": {
    "raw": "sparql-client-2",
    "scope": null,
    "escapedName": "sparql-client-2",
    "name": "sparql-client-2",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "http://registry.npmjs.org/sparql-client-2/-/sparql-client-2-0.6.1.tgz",
  "_shasum": "5af77a16f9067f2efd205e1d575998397421a67c",
  "_shrinkwrap": null,
  "_spec": "sparql-client-2",
  "_where": "/home/andrew/expressproj",
  "author": {
    "name": "Eddie Antonio Santos",
    "email": "easantos@ualberta.ca",
    "url": "http://eddieantonio.ca/"
  },
  "bugs": {
    "url": "https://github.com/eddieantonio/node-sparql-client/issues"
  },
  "contributors": [
    {
      "name": "Martin Franke",
      "email": "martin@semiwa.org",
      "url": "http://semiwa.org"
    },
    {
      "name": "Pieter Heyvaert",
      "email": "pheyvaer.heyvaert@ugent.be",
      "url": "http://semweb.mmlab.be/"
    },
    {
      "name": "Thomas Fritz",
      "email": "fritztho@gmail.com",
      "url": "http://fritzthomas.com"
    }
  ],
  "dependencies": {
    "denodeify": "^1.2.1",
    "lodash": "^4.0.1",
    "promise-nodeify": "^0.1.0",
    "request": "^2.40.0"
  },
  "description": "SPARQL Client for JavaScript",
  "devDependencies": {
    "eslint": "^3.11.0",
    "eslint-config-standard": "^6.2.1",
    "eslint-plugin-promise": "^3.4.0",
    "eslint-plugin-standard": "^2.0.1",
    "jasmine": "^2.3.1",
    "nock": "^2.5.0",
    "traceur": "0.0.90"
  },
  "directories": {
    "test": "spec"
  },
  "dist": {
    "shasum": "5af77a16f9067f2efd205e1d575998397421a67c",
    "tarball": "https://registry.npmjs.org/sparql-client-2/-/sparql-client-2-0.6.1.tgz"
  },
  "engines": {
    "node": ">= 0.10.0"
  },
  "gitHead": "1e310a1f4d53999dd10fcb1442a0d4b22e7d586e",
  "homepage": "https://github.com/eddieantonio/node-sparql-client",
  "keywords": [
    "sparql",
    "rdf"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "eddieantonio",
      "email": "easantos@ualberta.ca"
    }
  ],
  "name": "sparql-client-2",
  "optionalDependencies": {},
  "readme": "sparql-client\n=============\n\n[![Build Status](https://travis-ci.org/eddieantonio/node-sparql-client.svg?branch=master)](https://travis-ci.org/eddieantonio/node-sparql-client)\n[![npr Version](https://img.shields.io/npm/v/sparql-client-2.svg)](https://www.npmjs.com/package/sparql-client-2)\n\nA SPARQL 1.1 client for JavaScript.\n\n```javascript\nconst {SparqlClient, SPARQL} = require('sparql-client');\nconst client =\n  new SparqlClient('http://dbpedia.org/sparql')\n    .register({\n      db: 'http://dbpedia.org/resource/',\n      dbpedia: 'http://dbpedia.org/property/'\n    });\n\nfunction fetchCityLeader(cityName) {\n  return client\n    .query(SPARQL`\n           SELECT ?leaderName\n           WHERE {\n             ${{db: cityName}} dbpedia:leaderName ?leaderName\n           }`)\n    .execute()\n    // Get the item we want.\n    .then(response => Promise.resolve(response.results.bindings[0].leaderName.value));\n}\n\nfetchCityLeader('Vienna')\n  .then(leader => console.log(`${leader} is a leader of Vienna`));\n```\n\n\nTable of Contents\n=================\n\n  * [sparql-client](#sparql-client)\n  * [Use](#use)\n    * [Using `SPARQL` Tagged Template and Promises (ECMAScript 2015/ES 6)](#using-sparql-tagged-template-and-promises-ecmascript-2015es-6)\n    * [Using \"Traditional\" Node Callbacks](#using-traditional-node-callbacks)\n    * [Registering URI Prefixes](#registering-uri-prefixes)\n      * [Registering common prefixes](#registering-common-prefixes)\n      * [Registering custom prefixes](#registering-custom-prefixes)\n    * [Binding variables](#binding-variables)\n      * [Explicitly, using `#bind()`](#explicitly-using-bind)\n      * [Using the <code>SPARQL</code> template tag](#using-the-sparql-template-tag)\n    * [Updates](#updates)\n      * [Specifying a different update endpoint](#specifying-a-different-update-endpoint)\n    * [Errors](#errors)\n    * [Result Formatting](#result-formatting)\n  * [License](#license)\n\nUse\n===\n\n## Using `SPARQL` [Tagged Template][TT] and [Promises][] (ECMAScript 2015/ES 6)\n\nYou may use the `SPARQL` template tag to interpolate variables into the\nquery. All values are automatically converted into their SPARQL literal\nform, and any unsafe strings are escaped.\n\n```javascript\nconst SparqlClient = require('sparql-client');\nconst SPARQL = SparqlClient.SPARQL;\nconst endpoint = 'http://dbpedia.org/sparql';\n\nconst city = 'Vienna';\n\n// Get the leaderName(s) of the given city\nconst query =\n  SPARQL`PREFIX db: <http://dbpedia.org/resource/>\n         PREFIX dbpedia: <http://dbpedia.org/property/>\n         SELECT ?leaderName\n         FROM <http://dbpedia.org>\n         WHERE {\n           ${{db: city}} dbpedia:leaderName ?leaderName\n         }\n         LIMIT 10`;\n\nconst client = new SparqlClient(endpoint)\n  .register({db: 'http://dbpedia.org/resource/'})\n  .register({dbpedia: 'http://dbpedia.org/property/'});\n\nclient.query(query)\n  .execute()\n  .then(function (results) {\n    console.dir(results, {depth: null});\n  })\n  .catch(function (error) {\n    // Oh noes! ðŸ™€\n  });\n```\n\nResults in:\n\n```javascript\n{ head: { link: [], vars: [ 'leaderName' ] },\n  results:\n   { distinct: false,\n     ordered: true,\n     bindings:\n      [ { leaderName: { type: 'literal', 'xml:lang': 'en', value: 'Maria Vassilakou ,' } },\n        { leaderName: { type: 'literal', 'xml:lang': 'en', value: 'Michael HÃ¤upl' } },\n        { leaderName: { type: 'literal', 'xml:lang': 'en', value: 'Renate Brauner ;' } } ] } }\n```\n\n[TT]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings#Tagged_template_strings\n[Promises]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n\n## Using \"Traditional\" Node Callbacks\n\nYou are not forced to use promises; traditional `(err, results)`\ncallbacks work too. You may also use `#bind()` to replace `?variables`\nin the query with sanitized values:\n\n```javascript\n// Get the leaderName(s) of the 10 cities\nvar query = \"SELECT * FROM <http://dbpedia.org> WHERE { \" +\n  \"?city <http://dbpedia.org/property/leaderName> ?leaderName \" +\n  \"} LIMIT 10\";\nvar client = new SparqlClient( 'http://dbpedia.org/sparql')\n  .register({db: 'http://dbpedia.org/resource/'});\n\nclient.query(query)\n  .bind('city', {db: 'Vienna'})\n  .execute(function(error, results) {\n    console.dir(arguments, {depth: null});\n});\n```\n\n## Registering URI Prefixes\n\n### Registering common prefixes\n\nOften, SPARQL queries have many prefixes to register.\n\nCommon prefixes include:\n\nPrefix | URI\n-------|----\n`rdf`  | <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n`rdfs` | <http://www.w3.org/2000/01/rdf-schema#>\n`xsd`  | <http://www.w3.org/2001/XMLSchema#>\n`fn`   | <http://www.w3.org/2005/xpath-functions#>\n`sfn`  | <http://www.w3.org/ns/sparql#>\n\n\nYou may register any of the above by passing them to\n`#registerCommon()`. This may be done per-query:\n\n```javascript\nnew SparqlClient(endpoint)\n  .query(`SELECT ...`)\n  .registerCommon('xsd', 'sfn')\n  // Will have PREFIX xsd and sfn to this query only.\n  .execute();\n```\n\nOr on the client, affecting every subsequent query:\n\n```javascript\nclient\n  .registerCommon('rdfs', 'xsd');\n// Will add prefix rdfs and xsd.\nclient.query('...').execute();\n```\n\n### Registering custom prefixes\n\nUsing `#register()` on either the client or the query, you can register\nany arbitrary prefix:\n\n```javascript\nvar client = new SparqlClient(endpoint)\n  // Can register one at a time:\n  .register('ns', 'http://example.org/ns#')\n  // Can register in bulk, as an object:\n  .register({\n      db: 'http://dbpedia.org/resource/',\n      dbpedia: 'http://dbpedia.org/property/'\n  })\n  // Can register a BASE (empty prefix):\n  .register('http://example.org/books/');\n```\n\n## Binding variables\n\n### Explicitly, using `#bind()`\n\nIt's inadvisable to concatenate strings in order to write a query,\nespecially if data is coming from untrusted sources. `#bind()` allows\nyou to pass values to queries that will be converted into a safe SPARQL\nterm.\n\nSay you have a statement like this:\n\n```javascript\nvar text = 'INSERT DATA {' +\n  ' [] rdfs:label ?creature ;' +\n  '    dbfr:paws ?paws ;' +\n  '    dbfr:netWorth ?netWorth ;' +\n  '    dbfr:weight ?weight ;' +\n  '    dbfr:grumpy ?grumpy ;' +\n  '    dbfr:derrivedFrom ?derrivedFrom .' +\n  '}';\n```\n\nEach of the `?questionMarked` fields can be bound to JavaScript\nvalues while querying using `#bind()`:\n\n```javascript\nclient.query(text)\n  // Bind one at a time...\n  .bind('grumpy', true)\n  // Use a third argument to provide options.\n  .bind('derrivedFrom', 'http://fr.wikipedia.org/wiki/Grumpy_Cat?oldid=94581698', {type:'uri'})\n  // Or bind multiple values at once using an object:\n  .bind({\n    creature: {value: 'chat', lang: 'fr'},\n    paws: {value: 4, type: 'integer'},\n    netWorth: {value: '16777216.25', type: 'decimal'}, // francs\n    weight: 3.18, // kg\n  });\n```\n\n### Using the `SPARQL` template tag\n\nAny value that can be bound using `#bind()` can equally be interpolated\nusing the `SPARQL` template tag: URIs, strings, booleans, language\ntagged strings, doubles, literals with custom typesÂ­anything! Note the\ndoubled curly-braces (`${{value: ...}}`) when passing an object.\n\n```javascript\nvar text = SPARQL`\n  INSERT DATA {\n    ${{dc: 'eddieantonio'}} ns:favouriteGame ${{db: 'Super_Metroid'}} ;\n                rdfs:label ${'@eddieantonio'} ;\n                ns:prettyCheekyM8 ${true} ;\n                rdfs:label ${{value: 'ã‚¨ãƒ‡ã‚£', lang: 'jp'}} ;\n                ns:favoriteConstant ${Math.PI} ;\n                ns:favoriteColor ${{value: 'blue', datatype: {ns: 'Color'}}} .\n  }`;\n```\n\nThen `text` would be the string:\n\n```\n  INSERT DATA {\n    dc:eddieantonio ns:favouriteGame db:Super_Metroid ;\n                rdfs:label '@eddieantonio' ;\n                ns:prettyCheekyM8 true ;\n                rdfs:label 'ã‚¨ãƒ‡ã‚£'@jp ;\n                ns:favoriteConstant 3.141592653589793e0 ;\n                ns:favoriteColor 'blue'^^ns:Color .\n  }\n```\n\n## Updates\n\nThere's no need to specify anything special; `LOAD`, `CLEAR`, `DROP`,\n`ADD`, `MOVE`, `COPY`, `INSERT DATA`, and `DELETE DATA` are\nautomatically requested as updates. Just write these statements like any\nother:\n\n```javascript\nnew SparqlClient(endpoint).query(SPARQL`\n  INSERT DATA {\n    ${{pkmn: 'Lotad'}} pkdx:evolvesTo ${{pkmn: 'Lombre'}}\n    ${{pkmn: 'Lombre'}} pkdx:evolvesTo ${{pkmn: 'Ludicolo'}}\n  }`)\n  .execute();\n```\n\n### Specifying a different update endpoint\n\nSome servers have different endpoints for queries and updates. Specify\nthe alternate options when starting the client:\n\n```javascript\nvar client = new SparqlClient('http://example.org/query', {\n  updateEndpoint: 'http://example.org/update'\n});\n```\n\nYou may use the client subsequently:\n\n```javascript\n// Will be sent to http://example.org/update\nclient.query(SPARQL`\n  INSERT DATA {\n    ${{pkmn: 'Lotad'}} pkdx:evolvesTo ${{pkmn: 'Lombre'}}\n    ${{pkmn: 'Lombre'}} pkdx:evolvesTo ${{pkmn: 'Ludicolo'}}\n  }`)\n  .execute();\n\n// Will be sent to http://example.org/query\nclient.query(SPARQL`\n  SELECT {\n    ${{pkmn: 'Lombre'}} pkdx:evolvesTo ?evolution\n  }`)\n  .execute()\n  .then(response => {\n    // Prints Ludicolo\n    console.log(response.results.bindings[0].evolution.value)\n  });\n```\n\n### Overriding request defaults\n\nYou can override the request defaults by passing them in the options\nobject of the constructor. `defaultParams` are the default parameters in\nthe request, and `requestsDefaults` are the default _request options_.\nThis distinction is a little confusing, so here are some examples:\n\nFor example, say you have a graph database that expects `format: 'json'`\nas a param rather than the default `format:\n'application/sparql-results+json'`. You can override the default when\nconstructing your client like so:\n\n```js\nvar client = new SparqlClient('http://example.org/query', {\n  defaultParameters: {\n    format: 'json'\n  }\n});\n```\n\nSimilarly, let's say you want to specify your client's user agent\nstring. You can pass this, and other headers, as part of\na `requestsDefaults` option.\n\n```js\nvar client = new SparqlClient('http://example.org/query', {\n  requestsDefaults: {\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Accept': 'application/sparql-results+json,application/json',\n      'User-Agent': 'My Totally Sweet App - 1.0'\n    }\n  }\n});\n```\n\n## Errors\n\nIf an error occurs, such as when submitting a query with a syntax error,\nthe first argument to `execute()` will be an `Error` object and have\nthe `.httpStatus` attribute with the associated HTTP status code.\nUsually this is `400` when there is a syntax error, or `500` when the\nserver refuses to process the request (such as when a timeout occurs).\nThis status code is defined by the particular SPARQL server used.\n\n```javascript\nnew SparqlClient(endpoint).query(`\n    SELECT ?name\n    WHERE { ?x foaf:name ?name\n    ORDER BY ?name\n  `)\n  .execute(function (err, data) {\n    console.log(err.httpStatus);\n    // logs '400'\n    console.log(err);\n    // logs 'HTTP Error: 400 Bad Request'\n  });\n```\n\nThis also works with promises:\n\n```javascript\nnew SparqlClient(endpoint).query(`\n    SELECT ?name\n    WHERE { ?x foaf:name ?name\n    ORDER BY ?name\n  `)\n  .execute()\n  .then(function () {\n    // will never reach here!\n  })\n  .catch(function (err) {\n    console.log(err.httpStatus);\n    // logs '400'\n    console.log(err);\n    // logs 'HTTP Error: 400 Bad Request'\n  });\n```\n\n## Result Formatting\n\nWe may want to execute the following query (to retrieve all books and\ntheir genres).\n\n```sparql\nPREFIX dbpedia-owl: <http://dbpedia.org/owl/>\nSELECT ?book ?genre WHERE {\n    ?book dbpedia-owl:literaryGenre ?genre\n}\n```\nThe *default* formatting (when no options are provided) results, for the bindings (limited to two results in our example), in\n\n```javascript\n[\n  {\n    book: {\n      type: 'uri',\n      value: 'http://dbpedia.org/resource/A_Game_of_Thrones'\n    },\n    genre: {\n      type: 'uri',\n      value: 'http://dbpedia.org/resource/Fantasy'\n    }\n  },\n  {\n    book: {\n      type: 'uri',\n      value: 'http://dbpedia.org/resource/A_Game_of_Thrones'\n    },\n    genre: {\n      type: 'uri',\n      value: 'http://dbpedia.org/resource/Political_strategy'\n    }\n  }\n]\n```\n\nUsing the format option *resource* with the resource option set to\n*book* like so:\n\n```javascript\nquery.execute({format: {resource: 'book'}}, function(error, results) {\n  // ...\n});\n```\n\nResults in:\n\n```javascript\n[\n  {\n    book: {\n      type: 'uri',\n      value: 'http://dbpedia.org/resource/A_Game_of_Thrones'\n    },\n    genre: [\n      {\n        type: 'uri',\n        value: 'http://dbpedia.org/resource/Fantasy'\n      },\n      {\n        type: 'uri',\n        value: 'http://dbpedia.org/resource/Political_strategy'\n      }\n    ]\n  }\n]\n```\n\nThis makes it easier to process the results later (in the callback), because all the genres are connected to one book (in one binding), and not spread over several bindings.\nCalling the *execute* function will look something like this\n\n```javascript\nquery.execute({format: {resource: 'book'}}, function(error, results) {\n  console.dir(arguments, {depth: null});\n});\n```\n\nLicense\n=======\nThe MIT License\n\nCopyright Â© 2014 Thomas Fritz\n</br>Copyright Â© 2015, 2016 Eddie Antonio Santos\n\nContributors\n\n- Martin Franke (@MtnFranke)\n- Pieter Heyvaert ([@PHaDventure](https://twitter.com/PHaDventure))\n- Eddie Antonio Santos ([@eddieantonio](http://eddieantonio.ca/))\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/eddieantonio/node-sparql-client.git"
  },
  "scripts": {
    "test": "jasmine"
  },
  "version": "0.6.1"
}
